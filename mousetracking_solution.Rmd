---
title: "Mousetracking Analysis"
author: "Laura Bock Paulsen, Luke Ring"
date: "9/11/2022, updated 26/9/2023"
output: html_document
---

```{r helper_funcs, include=FALSE}
# For the touchtracking data, we can save a bunch of
# hassle by scaling the x/y coordinates within
# subjects. One caveat, mousetrap data comes with x and y coordinates
# in a column, but they are a chr with all the coordinates in one string
# that's the reason this looks so complicated, basically we're just:
# 1. splitting the string into a list
# 2. scaling the list
# 3. putting the list back together as a string

scale_raw_mousetrap_data <- function(df) {
  # Split data
  scale_raw_data <- function(x) {
    # helper function https://github.com/PascalKieslich/mousetrap/blob/master/R/import.R#L226C3-L243C66
    split <- ","
    # Remove all irrelevant characters
    x <- gsub(pattern=paste0("[^-e0123456789.",split,"]"),replacement = "", x)

    # Remove leading / end / double split characters
    x <- gsub(pattern=paste0("^",split),replacement = "", x)
    x <- gsub(pattern=paste0(split,"$"),replacement = "", x)
    x <- gsub(pattern=paste0(split,split),replacement = "", x)

    # Split according to specified character
    x <- strsplit(x, split=split)

    return(as.numeric(unlist(x)))
  }
  # get subject row indices by unique "subject_id" and "experiment_start_time" (in case two have the same id)
  idxs <- df %>%
    mutate(
      idx = row_number()
    ) %>%
    select(
      idx,
      subject_id
    )

  # now loop and scale/standardize each subject's data
  for (i in unique(idxs$subject_id)) {
    # get the indices for this subject
    idxs_sub <- idxs %>%
      filter(
        subject_id == i
      ) %>%
      pull(
        idx
      )

    # get the data for this subject
    subj_pos_data <- apply(
      df[idxs_sub, c(
          'xpos_tracking',
          'ypos_tracking'
        )
      ],
      c(1, 2),
      scale_raw_data
    )

    # get the lengths of the lists
    xpos_lengths <- sapply(subj_pos_data[, 'xpos_tracking'], length)
    ypos_lengths <- sapply(subj_pos_data[, 'ypos_tracking'], length)

    # flatten and scale the lists
    flattened_xpos <- scale(unlist(subj_pos_data[, 'xpos_tracking']))
    flattened_ypos <- scale(unlist(subj_pos_data[, 'ypos_tracking']))

    # put the data back together
    for (j in 1:length(idxs_sub)) {
      df[idxs_sub[j], 'xpos_tracking'] <- paste(flattened_xpos[1:xpos_lengths[j]], collapse = ',')
      df[idxs_sub[j], 'ypos_tracking'] <- paste(flattened_ypos[1:ypos_lengths[j]], collapse = ',')

      flattened_xpos <- flattened_xpos[(xpos_lengths[j] + 1):length(flattened_xpos)]
      flattened_ypos <- flattened_ypos[(ypos_lengths[j] + 1):length(flattened_ypos)]
    }
  }
  return(df)
}

```


For the analysis of your very own mouse-tracking data, we will be using a package called MouseTrap. In order to get acquainted with the package, we will play around with data from a single participant conduction the circle-square experiment. 

Alternatively, if you feel (ever so slightly) more adventerous, you can also use the data from the touch-tracking experiment. In this case, you will need to use the function "scale_raw_mousetrap_data" to scale the x and y coordinates within subjects. This is because the touch-tracking data needs to be standardized in some way despite differences in people's screen sizes. If you go for this option, you will have an advantage when it comes to analyzing your real data, because it will not be limited to a single subject (but you can ignore the screen size part, which is why it is included as a helper function and not part of the exercise itself). *Hint:* you can use `read_bulk` (from the package `readbulk`) to get all the CSV files from a single directory.

The documentation for the package can be found here: [http://pascalkieslich.github.io/mousetrap/reference/mousetrap.html](http://pascalkieslich.github.io/mousetrap/reference/mousetrap.html).

Use this page to solve the following steps by finding and applying appropriate mousetrap functions. Also, writing ?function_name() in the console is great way of reading about the function in question.

Call me for help whenever you get stuck (or take a quick look in the solutions file) :D

### Install packages and load in the data

*Note:* If you haven't encountered pacman before, it is an easy way to download and load packages for R. You will (only once) need to install packman with `install.packages("pacman")` in R. Afterwards, you can load and install packages with `pacman::p_load(package1, package2, package3)`. If you want to install a package without loading it, you can use `pacman::p_load(package1, package2, package3)`.

```{r setup, include=FALSE}
# loading packages
pacman::p_load(mousetrap, tidyverse, readbulk)

```

Single file:

```{r read_data_single}
# loading in data
d <- read_csv("log_files/subject-0.csv")

```

Touchtracker data:

```{r read_data_tt}
#read in data
d_tt <- read_bulk('log_files/', 
          extension = 'csv')

### forgot to track actual button click so the following code extracts the last x-position of the mouse, and infers the what button was clicked
#empty list
last_x_pos = c()
number_of_coords = c()

#for each list chars containing x-positios get the last value, turn into nuimeric and append to empty list
for (vector in d_tt$xpos_mouse) {
  number_vector <- (str_extract_all(vector, "-?\\d+\\.?\\d*"))
  numeric_vector <- as.numeric(unlist(number_vector))
  last_x_pos <- append(last_x_pos, tail(numeric_vector, 1))
  
  #also make a list that counts the number of coordinates counted per round
  number_of_coords <- append(number_of_coords, length(numeric_vector))
  
}

#save the list to the dataframe
d_tt$last_x_pos <- last_x_pos

#save the number of coordinates list
d_tt$number_of_coords <- number_of_coords

#add button clicked
d_tt <- d_tt %>% 
  mutate(button_clicked = if_else(last_x_pos < 0, "left_button", "right_button"))

#add whether participant made deontological or utilitarian judgment
d_tt <- d_tt %>% 
  mutate(judgement = if_else(
    button_clicked == deontological_button, "deontological", "utilitarian"
  ))

# #filter for only personal dilemmas
impersonal_dilemmas <- c("\\Standard Trolley\\", "\\Standard Fumes\\")
d_tt <- d_tt %>%
  filter(dilemma_name != impersonal_dilemmas) %>% 
  filter(number_of_coords > 10)



```


```{r mousetrap_tt}
m_tt <- mt_import_mousetrap(
  d_tt,
     verbose = TRUE
)
```


```{r plotting_tt}
# i
# note, different screen sizes will mean the data looks like it starts in different places
mt_plot(m_tt, color = "judgement")

```


### Mirror-symmetric mapping of movements

Touchtracker data:

```{r mirror_mapping_tt}

# now we can remap the trajectories
m_tt <- mt_remap_symmetric(
  m_tt,
  use = 'trajectories',
  remap_xpos = "right",
  remap_ypos = "up"
)

# plot again
mt_plot(
  m_tt, 
  use = 'trajectories',
  color = "judgement",
  wrap_var = "judgement")

```

```{r aggregated_plot_tt}
mt_plot_aggregate(
  m_tt, 
  color = "judgement",
  wrap_var = 'judgement'
)

m_tt_tn <- mt_time_normalize(
  m_tt,
  nsteps = 101,
  verbose = TRUE
)

mt_plot_aggregate(
  m_tt_tn, 
  color = "judgement",
  wrap_var = 'judgement'
)



```
